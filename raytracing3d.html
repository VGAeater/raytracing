<!DOCTYPE html>

<style>
  * {
    overflow: hidden;
    padding: 0;
    margin: 0;
    border: 0;
  }
</style>

<html>
  <body>
    <canvas id="canvas"></canvas>
    
    <script>
      var canvas = document.getElementById("canvas");
      var height = canvas.height = window.innerHeight;
      var width = canvas.width = window.innerWidth;
      var ctx = canvas.getContext("2d");
      
      var playerX = 1.5;
      var playerY = 1.5;
      var playerZ = 0.5;
      var playerDirectionX = 0;
      var playerDirectionY = 0;
      var FOV = 115;
      var FOVY = FOV / width * height;
      var resolution = width/16;
      var speed = 1;
      var prevTimeFPS = prevTimeMove = new Date();
      const degToRad = 1/180*Math.PI;
      
      var pressedKeys = {};
      window.onkeyup = function(e) { pressedKeys[e.key] = false; }
      window.onkeydown = function(e) { pressedKeys[e.key] = true; }
      
      map = [
        [1,1,1,1,1,1,1,1],
        [1,0,1,1,0,1,0,1],
        [1,0,0,1,0,1,0,1],
        [1,1,0,0,0,1,0,1],
        [1,0,0,1,0,1,0,1],
        [1,0,1,0,0,1,0,1],
        [1,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1]
      ]
      
      function findMapVal(x, y, r) {
        if (y >= map.length || y < 0) {
          return 1;
        }
        if (x >= map[Math.floor(y)].length || x < 0) {
          return 1;
        }
        
        //return map[y][x];
        //return map[Math.floor(y)][Math.floor(x)];
        
        
        if (map[Math.floor(x-r)][Math.floor(y-r)] == 1) {
          return 1;
        }
        if (map[Math.floor(x-r)][Math.floor(y+r)] == 1) {
          return 1;
        }
        if (map[Math.floor(x+r)][Math.floor(y-r)] == 1) {
          return 1;
        }
        if (map[Math.floor(x+r)][Math.floor(y+r)] == 1) {
          return 1;
        }
        
        //try {
        //  for (let i = -r; i<=r; i+=r) {
        //    for (let j = -r; j<=r; j+=r) {
        //      a = x + i;
        //      b = y + j;
        //      if (b <= map.length && b > 0) {
        //        if (a <= map[Math.floor(b)].length && a > 0) {
        //          if (map[Math.floor(b)][Math.floor(a)] == 1) {
        //            return 1;
        //          }
        //        }
        //      }
        //    }
        //  }
        //}
        //catch(err) {
        //  alert(err);
        //}
        
        return 0;
      }
      
      const distance = (x1, y1, z1, x2, y2, z2) => Math.hypot(x2 - x1, y2 - y1, z2 - z1);
      
      function ray(directionX, directionY) {
        let x = playerX;
        let y = playerY;
        let z = playerZ;
        
        while (distance(playerX, playerY, playerZ, x, y, z) < 5) {
          let r = 0.25;
          while (findMapVal(x, y, r) == 1 || z-r < 0 || z+r > 1) {
            r *= 0.5;
            if (r < 0.001) {
              return [distance(playerX, playerY, playerZ, x, y, z), [x, y, z]];
            }
          }
          x += Math.cos(directionX*degToRad)*r;
          y += Math.sin(directionX*degToRad)*r;
          z += Math.sin(directionY*degToRad)*r;
          if (z < 0 || z > 1) {
            return [distance(playerX, playerY, playerZ, x, y, z), [x, y, z]];
          }
        }
        return [5, [x, y, z]];
      }
      
      function render() {
        //var grd = ctx.createLinearGradient(0,0,0,height);
//grd.addColorStop(0,"green");
//grd.addColorStop(0.5,"rgb(0,100,0)");
//grd.addColorStop(1,"green");

// Fill with gradient
//ctx.fillStyle = grd;
        ctx.fillStyle = "green";
        ctx.fillRect(0, 0, width, height)
        let distance = 8;
        try {
        for (let directionX = playerDirectionX-(FOV/2); directionX <= playerDirectionX+(FOV/2); directionX += FOV/resolution) {
          for (let directionY = playerDirectionY-(FOVY/2); directionY <= playerDirectionY+(FOVY/2); directionY += FOVY/resolution) {
            rayOutput = ray(directionX, directionY);
            distance = rayOutput[0];
            collision = rayOutput[1];
            //distance = distance*Math.cos((directionX-playerDirectionX)/360*Math.PI*2);
            if (collision[2] > 0.998 || collision[2] < 0.002) {
              ctx.fillStyle = "hsl(0, 100%, " + (100-distance*20+((Math.floor(collision[0])+Math.floor(collision[1]))%2*30+1)) + "%)";
            } else {
              ctx.fillStyle = "hsl(180, 100%, " + (100-distance*20) + "%)";
            }
            ctx.fillRect((directionX-playerDirectionX)*width/FOV+width/2, -(directionY-playerDirectionY)*width/FOVY+height/2, width/resolution, width/resolution+0.5);
          }
        }
        } catch(err) {
          alert(err);
        }
      }
      
      function drawFps() {
        //ctx.fillStyle = "white";
        //var grad = ctx.createLinearGradient(0,0,200, 0);
        //grad.addColorStop(0, "red");
        //grad.addColorStop(1, "green");
        //ctx.fillStyle = grad;
        //ctx.strokeStyle = "black";
        //ctx.lineWidth = 4;
        //ctx.beginPath();
        //ctx.arc(100, 100, 90, Math.PI, 0);
        //ctx.fill();
        //ctx.stroke();
        //ctx.beginPath();
        //ctx.moveTo(10, 100);
        //ctx.lineTo(190, 100);
        //ctx.stroke();
        //ctx.beginPath();
        //ctx.moveTo(100, 100);
        //let currentTime = new Date();
        //ctx.lineTo(100-Math.cos(Math.log(1000/(currentTime-prevTime))/5*Math.PI)*80, 100-Math.sin(Math.log(1000/(currentTime-prevTime))/5*Math.PI)*80);
        ////ctx.lineTo(100-Math.cos(Math.log(1000/30)/5*Math.PI)*80, 100-Math.sin(Math.log(1000/30)/5*Math.PI)*80);
        //ctx.stroke();
        //prevTime = currentTime;
        
        
        let currentTime = new Date();
        ctx.lineWidth = 20;
        ctx.strokeStyle = "white";
        ctx.beginPath();
        ctx.moveTo(20, 30);
        ctx.lineTo(20+1000/(currentTime-prevTime)*5, 30);
        ctx.stroke();
        prevTimeFPS = currentTime;
        
        ctx.lineWidth = 10;
        ctx.strokeStyle = "orange";
        ctx.beginPath();
        ctx.moveTo(20+30*5, 20);
        ctx.lineTo(20+30*5, 40);
        ctx.stroke();
        
        ctx.strokeStyle = "green";
        ctx.beginPath();
        ctx.moveTo(20+60*5, 20);
        ctx.lineTo(20+60*5, 40);
        ctx.stroke();
      }
      
      function move() {
        let currentTime = new Date();
        let dist = (currentTime - prevTimeMove)/1000*speed;
        prevTimeMove = currentTime;

        if (pressedKeys["ArrowLeft"]) {
          playerDirectionX -= 3;
        }
        if (pressedKeys["ArrowRight"]) {
          playerDirectionX += 3;
        }
        if (pressedKeys["ArrowUp"] || pressedKeys["w"]) {
          playerX += Math.cos(playerDirectionX*degToRad)*dist;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerX -= Math.cos(playerDirectionX*degToRad)*0.01;
            }
          }
          playerY += Math.sin(playerDirectionX*degToRad)*dist;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerY -= Math.sin(playerDirectionX*degToRad)*0.01;
            }
          }
        }
        if (pressedKeys["ArrowDown"] || pressedKeys["s"]) {
          playerX -= Math.cos(playerDirectionX*degToRad)*dist;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerX += Math.cos(playerDirectionX*degToRad)*0.01;
            }
          }
          playerY -= Math.sin(playerDirectionX*degToRad)*dist;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerY += Math.sin(playerDirectionX*degToRad)*0.01;
            }
          }
        }
        if (pressedKeys["a"]) {
          playerX -= Math.cos(playerDirectionX*degToRad+Math.PI/2)*dist;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerX += Math.cos(playerDirectionX*degToRad+Math.PI/2)*0.01;
            }
          }
          playerY -= Math.sin(playerDirectionX*degToRad+Math.PI/2)*dist;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerY += Math.sin(playerDirectionX*degToRad+Math.PI/2)*0.01;
            }
          }
        }
        if (pressedKeys["d"]) {
          playerX += Math.cos(playerDirectionX*degToRad+Math.PI/2)*dist;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerX -= Math.cos(playerDirectionX*degToRad+Math.PI/2)*0.01;
            }
          }
          playerY += Math.sin(playerDirectionX*degToRad+Math.PI/2)*dist;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerY -= Math.sin(playerDirectionX*degToRad+Math.PI/2)*0.01;
            }
          }
        }
      }
      
      function main() {
        render();
        drawFps();
      }
      
      const interval = setInterval(main, 30);
      const moveInterval = setInterval(move, 10);
      
      document.addEventListener("mousemove", function(e) {
        playerDirectionX += e.movementX/4;
        playerDirectionY -= e.movementY/4;
        if (playerDirectionY > 90) {
          playerDirectionY = 90;
        } else if (playerDirectionY < -90) {
          playerDirectionY = -90;
        }
      });
      
      canvas.onclick = () => {
        canvas.requestPointerLock();
      }
    </script>
  </body>
</html>
