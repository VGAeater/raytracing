<!DOCTYPE html>

<style>
  * {
    overflow: hidden;
    padding: 0;
    margin: 0;
    border: 0;
  }
</style>

<html>
  <body>
    <canvas id="canvas"></canvas>
    
    <script>
      var canvas = document.getElementById("canvas");
      var height = canvas.height = window.innerHeight;
      var width = canvas.width = window.innerWidth;
      var ctx = canvas.getContext("2d");
      
      var playerX = 1.5;
      var playerY = 1.5;
      var playerDirectionX = 0;
      var playerDirectionY = 0;
      var FOV = 90;
      var resolution = width/8;
      var prevTime = new Date();
      
      var pressedKeys = {};
      window.onkeyup = function(e) { pressedKeys[e.key] = false; }
      window.onkeydown = function(e) { pressedKeys[e.key] = true; }
      
      map = [
        [1,1,1,1,1,1,1,1],
        [1,0,1,1,0,1,0,1],
        [1,0,0,1,0,1,0,1],
        [1,1,0,0,0,1,0,1],
        [1,0,0,1,0,1,0,1],
        [1,0,1,0,0,1,0,1],
        [1,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1]
      ]
      
      function findMapVal(x, y, r) {
        if (y >= map.length || y < 0) {
          return 1;
        }
        if (x >= map[Math.floor(y)].length || x < 0) {
          return 1;
        }
        
        //return map[y][x];
        //return map[Math.floor(y)][Math.floor(x)];
        
        
        if (map[Math.floor(x-r)][Math.floor(y-r)] == 1) {
          return 1;
        }
        if (map[Math.floor(x-r)][Math.floor(y)] == 1) {
          return 1;
        }
        if (map[Math.floor(x-r)][Math.floor(y+r)] == 1) {
          return 1;
        }
        if (map[Math.floor(x)][Math.floor(y-r)] == 1) {
          return 1;
        }
        if (map[Math.floor(x)][Math.floor(y)] == 1) {
          return 1;
        }
        if (map[Math.floor(x)][Math.floor(y+r)] == 1) {
          return 1;
        }
        if (map[Math.floor(x+r)][Math.floor(y-r)] == 1) {
          return 1;
        }
        if (map[Math.floor(x+r)][Math.floor(y)] == 1) {
          return 1;
        }
        if (map[Math.floor(x+r)][Math.floor(y+r)] == 1) {
          return 1;
        }
        
        //try {
        //  for (let i = -r; i<=r; i+=r) {
        //    for (let j = -r; j<=r; j+=r) {
        //      a = x + i;
        //      b = y + j;
        //      if (b <= map.length && b > 0) {
        //        if (a <= map[Math.floor(b)].length && a > 0) {
        //          if (map[Math.floor(b)][Math.floor(a)] == 1) {
        //            return 1;
        //          }
        //        }
        //      }
        //    }
        //  }
        //}
        //catch(err) {
        //  alert(err);
        //}
        
        return 0;
      }
      
      const distance = (x1, y1, z1, x2, y2, z2) => Math.hypot(x2 - x1, y2 - y1, z2 - z1);
      
      function ray(directionX, directionY) {
        let x = playerX;
        let y = playerY;
        let z = 0.5;
        
        while (distance(playerX, playerY, 0.5, x, y, z) < 16) {
          let r = 0.5;
          while (true) {
            if (findMapVal(x, y, r) == 1) {
              r *= 0.5;
            } else {
              break
            }
            if (r < 0.01) {
              return [distance(playerX, playerY, 0.5, x, y, z), [x, y, z]];
            }
          }
          x += Math.cos(directionX/360*Math.PI*2)*Math.cos(directionY/360*Math.PI*2)*r;
          y += Math.sin(directionX/360*Math.PI*2)*Math.cos(directionY/360*Math.PI*2)*r;
          z += Math.sin(directionY/360*Math.PI*2)*r;
          if (z < 0 || z > 1) {
            return [distance(playerX, playerY, 0.5, x, y, z), [x, y, z]];
          }
        }
        return 16;
      }
      
      function render() {
        //var grd = ctx.createLinearGradient(0,0,0,height);
//grd.addColorStop(0,"green");
//grd.addColorStop(0.5,"rgb(0,100,0)");
//grd.addColorStop(1,"green");

// Fill with gradient
//ctx.fillStyle = grd;
        ctx.fillStyle = "green";
        ctx.fillRect(0, 0, width, height)
        let distance = 8;
        let FOVY = FOV / width * height * 2;
        try {
        for (let directionX = playerDirectionX-(FOV/2); directionX <= playerDirectionX+(FOV/2); directionX += FOV/resolution) {
          for (let directionY = playerDirectionY-(FOVY/2); directionY <= playerDirectionY+(FOVY/2); directionY += FOVY/resolution) {
            rayOutput = ray(directionX, directionY);
            distance = rayOutput[0];
            collision = rayOutput[1];
            //distance = distance*Math.cos((directionX-playerDirectionX)/360*Math.PI*2);
            if (collision[2] > 1 || collision[2] < 0) {
              ctx.fillStyle = "hsl(0, 75%, " + distance*6.25 + "%)";
            } else {
              ctx.fillStyle = "hsl(180, 75%, " + distance*6.25 + "%)";
            }
            ctx.fillRect((directionX-playerDirectionX)*width/FOV+width/2, (directionY-playerDirectionY)*width/FOVY+height/2, width/resolution, width/resolution+0.5);
          }
        }
        } catch(err) {
          alert(err);
        }
      }
      
      function drawFps() {
        ctx.fillStyle = "black";
        var grad = ctx.createLinearGradient(0,0,200, 0);
        grad.addColorStop(0, "red");
        grad.addColorStop(1, "green");
        ctx.fillStyle = grad;
        ctx.strokeStyle = "black";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(100, 100, 90, Math.PI, 0);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(10, 100);
        ctx.lineTo(190, 100);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(100, 100);
        let currentTime = new Date();
        ctx.lineTo(100-Math.cos(Math.log(1000/(currentTime-prevTime))/5*Math.PI)*80, 100-Math.sin(Math.log(1000/(currentTime-prevTime))/5*Math.PI)*80);
        //ctx.lineTo(100-Math.cos(Math.log(1000/30)/5*Math.PI)*80, 100-Math.sin(Math.log(1000/30)/5*Math.PI)*80);
        ctx.stroke();
        prevTime = currentTime;
      }
      
      function move() {
        if (pressedKeys["ArrowLeft"]) {
          playerDirectionX -= 3;
        }
        if (pressedKeys["ArrowRight"]) {
          playerDirectionX += 3;
        }
        if (pressedKeys["ArrowUp"] || pressedKeys["w"]) {
          playerX += Math.cos(playerDirectionX/360*Math.PI*2)*0.05;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerX -= Math.cos(playerDirectionX/360*Math.PI*2)*0.001;
            }
          }
          playerY += Math.sin(playerDirectionX/360*Math.PI*2)*0.05;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerY -= Math.sin(playerDirectionX/360*Math.PI*2)*0.001;
            }
          }
        }
        if (pressedKeys["ArrowDown"] || pressedKeys["s"]) {
          playerX -= Math.cos(playerDirectionX/360*Math.PI*2)*0.05;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerX += Math.cos(playerDirectionX/360*Math.PI*2)*0.001;
            }
          }
          playerY -= Math.sin(playerDirectionX/360*Math.PI*2)*0.05;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerY += Math.sin(playerDirectionX/360*Math.PI*2)*0.001;
            }
          }
        }
        if (pressedKeys["a"]) {
          playerX -= Math.cos(playerDirectionX/360*Math.PI*2+Math.PI/2)*0.05;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerX += Math.cos(playerDirectionX/360*Math.PI*2+Math.PI/2)*0.001;
            }
          }
          playerY -= Math.sin(playerDirectionX/360*Math.PI*2+Math.PI/2)*0.05;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerY += Math.sin(playerDirectionX/360*Math.PI*2+Math.PI/2)*0.001;
            }
          }
        }
        if (pressedKeys["d"]) {
          playerX += Math.cos(playerDirectionX/360*Math.PI*2+Math.PI/2)*0.05;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerX -= Math.cos(playerDirectionX/360*Math.PI*2+Math.PI/2)*0.001;
            }
          }
          playerY += Math.sin(playerDirectionX/360*Math.PI*2+Math.PI/2)*0.05;
          if (findMapVal(playerX, playerY, 0.2) == 1) {
            while (findMapVal(playerX, playerY, 0.2) == 1) {
              playerY -= Math.sin(playerDirectionX/360*Math.PI*2+Math.PI/2)*0.001;
            }
          }
        }
      }
      
      function main() {
        render();
        drawFps();
      }
      
      const interval = setInterval(main, 4);
      const moveInterval = setInterval(move, 10);
      
      document.addEventListener("mousemove", function(e) {
        playerDirectionX += e.movementX/4;
        playerDirectionY += e.movementY/4;
      });
      
      canvas.onclick = () => {
        canvas.requestPointerLock();
      }
    </script>
  </body>
</html>
